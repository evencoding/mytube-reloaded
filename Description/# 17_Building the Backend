1. 백엔드 서버를 빌드
2. 클라이언트 코드를 빌드

-----------------------------------------------------------------------------------
# 17.0 Building the Backend
    (1) Heroku를 통해 배포
        1. 어떤 node.js 환경에서도 서버가 실행될 수 있게 설정을 바꿔야 한다
        2. DB 설정을 바꿔야한다
        3. 파일들을 서버가 아닌 아마존에 올려야한다
        4. 코드를 production 방법으로 빌드해야 하고, 코드를 압축(minify) 해야한다
    (2) 현재 내가 만든 코드를 실행하려면 nodemon 을 사용해서 babel-node 를 실행한다
        babel-node는 실제로 서비스 되는 곳이 아니라 개발할 때만 사용되는 목적으로 쓴다
            babel-node가 그렇게 빠르지 않아서 performance 문제가 있기 때문
        따라서 init.js 를 일반적인 javascript 코드로 바꿔야 한다
            Babel CLI 사용 (호환성 있는 코드로 바꿔준다)
        scripts에 "build:server": "babel src/init.js -d build" 를 추가했다
            -d 로 특정 directory (빌드한 코드를 어디에 저장할 지)를 지정할 수 있다
        실행해보면 build 폴더에 init.js 파일만 생성된 것을 볼 수 있다
            이처럼 babel CLI는 nodemon처럼 움직이지 않는다
                (nodemon은 파일을 실행하고 그 파일이 모든 걸 실행)
            따라서 babel의 경우, 한 파일만 실행하는 게 아니라 모든 폴더를 빌드해서 실행해야 한다
        scripts를 "build:server": "babel src -d build" 로 수정해서 src 폴더 자체를 빌드한다
    (3) build 폴더를 .gitignore에 추가
    (4) 코드를 빌드할 때 client 부분 코드도 빌드하는 문제점이 발생했다
        백엔드를 babel로 바꾸는 것이기 때문에 client 코드를 빌드하면 안된다
            나중에 수정
    (5) scripts에 "start": "node build/init.js"를 만들어서 bulid/init.js 를 실행한다
            빌드폴더안에 init.js는 일반 javascript 코드이기 때문에 node는 babel이 없어도 이해할 수 있다
        에러
            1. 실행하면 ReferenceError: regeneratorRuntime is not defined 가 뜨는데,
                init파일에 import "regenerator-runtime"; 해준다 (async와 await를 사용할 수 있게 알려줘야함)
            2. src를 빌드했는데 그 중에 폴더 하나가 없다 (views)
        에러 수정 후 npm start로 실행하면 정상 작동한다
        이제 babel이 서버에서 실행되지 않고, node.js가 서버에서 실행되고 있다
    (6) 왜 views 폴더가 build되지 않았을까
        답은 빌드된 server.js에 있다
            build의 backend가 직접 /src/views로 이동했기 때문이다
    (7) 빌드 서버는 환경 변수에 접근할 수 있다
-----------------------------------------------------------------------------------
# 17.2 Building the Frontend
    (1) webpack은 두가지 모드가 있다
        1. development와 production
            production 코드가 훨씬 더 작다
    (2) 따라서 assets를 빌드한다
        1. webpack.config.js에서 지정했던 mode를 지우고 scripts에서 명령어로 전달한다
            "build:assets":"webpack --mode=production"
        실행하면 모든 게 production 을 위해 빌드 된다
    (3) 문제는 build:assets을 했지만 webpack은 여전히 watch 모드에 있다
        development 모드에서만 watch 모드를 true로 해야한다
            따라서 webpack.config.js에서 "watch:true"를 지우고, 명령어로 전달한다
            "dev:assets": "webpack --mode=development -w"
            watch 모드에서는 파일이 수정되면 다시 실행하지만
            그렇지 않을 때는 빌드만하고 끝난다
    (4) 이제 build:server를 실행할 수 있다
        build server 는 build assets을 보게 된다
        이때 실행하는 모든 코드는 공개할 준비가 된(profuction-ready) 자바스크립트 코드다
        어떤 서버에서든, 브라우저에서든 이해할 수 있다
    (5) build:server 와 build:assets을 묶어준다
        "build":"npm run build:server && npm run build:assets",
    (6) 이걸 Heroku에 추가한다
        Heroku에 두는 이유는 이걸 실제 서버에 뒀을 때 어떻게 에러가 생길 지 보기 위해
-----------------------------------------------------------------------------------
# 17.3 Deploying to Heroku
    (1) Heroku는 서버를 아주 빠르게 배포할 수 있다
    (2) Heroku에서 app을 만든다
    (3) Heroku에 백엔드 서버를 업로드하는 두 가지 방법이 있다
        1. Github
        2. Heroku Git
            Heroku CLI를 설치해야 한다
            step1. heroku login
            step2. 내 프로젝트 안으로 이동 (heroku git:remote -a jungtube)
                Heroku remote 하나를 얻는다
                    즉, git에서 add, commit 등등을 하고 push를 Heroku에 할 수 있다는 말이다
            Heroku는 오직 내 git history만 본다
                만약 코드를 바꾸고 commit을 안하면 Heroku가 나의 코드를 볼 수 없다
                그래서 매번 코드를 바꾸면 항상 commit을 해야한다
            git push heroku master 로 배포한다
                그전에 server나 Heroku의 로그를 볼 수 있는 command를 실행 한다 (heroku logs --tail)
            heroku는 기본적으로 npm start를 실행한다
        -Error
            commit 하지 않았을 때 (Model not found)
            Error: Cannot init client. Please provide correct options
                connect-mongo 에서 발생한 에러
                heroku가 보는 모든 파일은 Github가 보는 파일이다
                현재 DB의 url은 process.env.DB_URL을 사용하고있다
                문제는 .env가 Heroku에 없다 (GitHub에게 무시당했기 때문에)
                Github에 .env 파일은 절대 올려서는 안되기 때문에 process.env.DB_URL을 더 좋은 방법으로 설정해야한다
-----------------------------------------------------------------------------------
# 17.4 MongoDB Atlas
    (1) mongoDB Atlas 계정을 생성
        mongoDB 데이터베이스를 얻을 수 있다
    (2) mongoDB Atlas에 새로운 프로젝트를 만들고 cluster를 추가한다
        cluster 는 database group과 같은 것이다 (Free cluster. 다른 cluster에 비해 느릴것이다)
    (3) Database가 만들어진다
        connect 버튼을 눌러주고 IP 주소를 연결하기 위한 작업을 해준다
        모두 접속 가능하게 한다
        하지만 연결하고 싶다면 DB의 계정 이름과 비밀번호를 알아야 한다
            내가 기억할 username을 만든다 (jungwoo)
            DB의 비밀번호는 반드시 안전해야 한다
        이렇게 Database User를 만든다
    (4) Choose a connection method 를 누르면 어떻게 연결하고 싶은지 물어본다
        이번 프로젝트에서는 MongoDB의 native driver를 사용해서 앱과 연결한다
        DB의 URL이 나오는데 이 URL이 .env파일에 있는 DB_URL과 같은 것이다 (실제 DB)
            .env파일에 있는 URL은 localhost를 위한 URL
    (5) process.env.DB_URL이 heroku에 없다는 게 문제였다
        DB의 URL은 얻었지만 어떻게 process.env.DB_URL에 둬야 할까
    (6) Heroku의 admin panel을 사용해서 이 DB_URL을 설정한다
        Heroku의 설정에서 "Reveal Config Vars"를 누른다
            여기서 변수를 추가할 수 있다
        Heroku에서는 .env 파일에 있는 DB_URL을 읽지 못하기 때문에 (Github에 올리지 않기 때문)
        웹 사이트에서 변수를 설정한다
            변수에 DB_URL을 주는 것으로 DB에 연결할 수 있다
    (7) server.js에서 secret 옵션인 express-session을 주지 않았다
        Heroku에서  COOKIE_SECRET 변수를 추가한다
            내가 원하는 값으로 맘대로 적어도 된다 (아무도 알아선 안되고 공백은 없어야 한다)
                이게 나의 COOKIE_SECRET이 된다
    (8) Web process failed to bind to $PORT within 60 seconds of launch 에러가 발생했는데,
        Heroku가 내 서버에 열어준 PORT와 연결되지 않았기 때문이다
-----------------------------------------------------------------------------------
# 17.5 Environment Variables
    (1) 대부분 Heroku는 랜덤으로 Port를 준다
        따라서 포트번호는 내가 지정한 걸로 연결해서는 안된다 (Heroku가 준 Port로 연결해야 한다)
        DB_URL처럼 Heroku가 PORT변수를 준다
            const PORT = process.env.PORT || 5000;
                process.env.PORT
                    Heroku에서 준 PORT
                5000
                    내 컴퓨터에서의 PORT
        파일을 수정했기 때문에 commit, push 등을 해줘야한다
    (2) 여기까지하면 사이트를 배포가 완료된다
        하지만 아무런 비디오도 존재하지 않는다
            DB에 비디오가 없기 때문에
    (3) 또 Github 로그인이 404 status가 된다
        client_id가 정의돼 있지 않기때문
            GH_CLIENT, GH_SECRET 이 .env 파일안에 선언되어 있다
    (4) Heroku에서 Config Vars를 설정하면 꼭 Hide Config Vars를 해줘야한다
        매우 민감한 내용이기 때문
-----------------------------------------------------------------------------------
# 17.6 Github and AWS S3 part One
    (1) Github 로그인 시에 또 다른 문제가 발생한다
        localhost:4000으로 리다이렉트 해버렸다 (그렇게 로직을 짰기 때문)
        Github App 에서 수정해야 한다
        Developer settings 에서 callback URL을 변경한다
            내 Heroku URL로 변경
            내 컴퓨터에서 GitHub 로그인을 테스트할 때 다시 바꿔줘야 해서 조금 귀찮을 수 있다
                앱을 두 개 만들어두는 방법도 있다
                    1. 공식앱 (Heroku를 사용하는 앱)
                        Heroku의 Config 변수로 Client ID와 Client Secret이 있다
                    2. 테스트 앱
                        .env 파일에 Client ID와 Client Secret이 있다
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
