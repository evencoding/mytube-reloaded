-----------------------------------------------------------------------------------
# 6.0 Array Database part One
    (1) back end 에 데이터를 저장하는게 요점이기 때문에 어떻게 back end 에 데이터 보내야하는가를 먼저 알아야 한다
    (2) 현재 Router에서 내가 하고있는 건 get 뿐이다
        post하는 방법을 알아야 한다
    (3) pug에서 태그의 attribute에서 #{}는 사용할 수 없다
        변수를 사용할 때는 JS의 백틱 format을 사용한다 or "~~" + 변수
-----------------------------------------------------------------------------------
# 6.1 Array Database part Two
    (1) ternary operator #{~~ === ~ ? "~~"}
    (2) a태그의 href의 앞머리 부분에 "/~~"를 넣으면 내가 어디에 있든 상관없이 root + ~~로 이동한다
        absolute url
    (3) a태그의 href의 앞머리 부분의 /를 지우고 "~~"를 적으면 내가 있던 곳/~~로 이동한다
        relative url
-----------------------------------------------------------------------------------
# 6.2 Edit Video part One
    (1) form태그에 action 속성에 데이터를 어디로 보낼지가 들어간다
        action이 없으면 같은 url로 데이터를 보냄
    (2) method를 안적어주면 디폴드 값인 GET method가 사용된다
    (3) GET과 POST의 차이를 알기위해 input에 name 속성을 준다
    (4) GET Method를 사용하면, form에 있는 정보가 url에 들어가게 된다
    (5) POST 방식은 파일을 보내거나, database에 있는 값을 바꾸는 뭔가를 보낼 때 사용한다
    (6) 서버에게 post가 뭔지 알려줘야한다
        Router에서 videoRouter.post("url", function);
-----------------------------------------------------------------------------------
# 6.3 Edit video part Two
    (1) get, post가 같은 url일 때는 route를 만들어서 한번에 쓸 수 있다
        videoRouter.route("/:id(\\d+)/edit").get(getEdit).post(postEdit);
    (2) res.redirect()는, 브라우저가 redirect(자동으로 이동)하도록 하는 것이다
    (3) 이 단계에서 express application은 form을 어떻게 다루는지 모른다
    (4) express.urlencoded  form의 body를 이해한다
        1. parameterLimit를 써서, 필요하다면 parameter 갯수에 제한을 줄 수도 있다.
        2. limit를 써서 form의 사이즈에 제한을 줄 수 있다.
        3. extended는 body에 있는 정보들을 보기 좋게 형식을 갖춰주는 일을 한다.
            자바스크립트 object 형색으로 form의 데이터를 준다
        routes를 사용하기 전에 이 middleware를 사용해야 한다
    (5) app.use(express.urlencoded({ extended: true }));
        나의 express application이 form의 value들을 이해할 수 있도록 하고, 
        내가 쓸 수 있는 자바스크립트 형식으로 변형시켜준다
            데이터를 받기위해 input에 name을 줘야함
-----------------------------------------------------------------------------------
# 6.4 Recap
    (1) form을 이용해서 POST로 back end로 데이터를 보냄
    (2) req.body는 form에 있는 value의 JS representation이다
    (3) req.body로 접근할 수 있지만 한가지 middleware를 설정해야한 가능하다
    (4) app.use(express.urlencoded({ extended: true }));
        HTML form을 이해하고 그 form을 사용할 수 있는 JS Object 형식으로 통역해준다
    (5) 이 middleware가 라우터들 전에 오기 때문에!, post를 받기전에 request에 body가 있는 것이다
    (6) mongoose를 통해서, 자바스크립트에서 mongodb와 상호작용 한다
-----------------------------------------------------------------------------------
# 6.5 More Practice part One
    (1) 6.2, 6.3 내용 연습
        Controller
            1. 유저가 form을 볼 수 있어야 하기 때문에 get을 만든다
            2. post로 데이터를 받았을 때 처리할 post를 만든다
        Router
            라우트를 만들어 준다
        url로 가는 링크를 만든다
            view파일
-----------------------------------------------------------------------------------
# 6.6 More Practice part Two
    (1) 6.2, 6.3 내용 연습
    (2) GET url과 POST로 데이터를 보낼 url이 같으면 action 속성을 생략해도 된다
    (3) input으로부터 data를 얻는 방법 (name속성이 존재해야함)
            res.body
                app.use(express.urlencoded({ extended: true })); 가 라우터들 위에 있어야함
-----------------------------------------------------------------------------------
# 6.7 Introduction to MongoDB
    (1) document-based(문서 기반) DB
            database도 object로 생각함
            즉, mongoDB에서 저장하는 것들은 JSON-like-document다
            또, mongoDB는 document 내부를 검색할 수 있도록 해준다
        보통의 DB들은 sql base(행,열 기반)이다
    (2) mongoDB 설치
            Docs -> Server -> installation
            Window10에선 Chocolatey
                Windows 유저들을 위한 package 매니저이다
-----------------------------------------------------------------------------------
# 6.8 Connecting to Mongo
    (1) mongoose
        1. mongoose는 node.js와 mongoDB를 이어주는 다리가 되어준다
        2. 자바스크립트로 적으면, mongoose가 mongoDB에게 전해준다
    (2) cmd에서 mongod 로 재대로 설치되었는지 확인하고, mongo 커맨드로 mongoDB와 cmd와 연결 해준다
        exit로 나갈 수 있다
    (3) npm i mongoose로 mongoose를 설치한다
    (4) src 폴더 안에 db.js 파일을 생성한다
    (5) database가 실행되고 있는 url을 알아야한다
        mongo 명령어를 console에서 실행시켜서, url을 받아야함
    (6) mongoose를 import 하고 mongoose.connect("url/databaseName") 로 url/databaseName을 넣어준다
        mongoose.connect("mongodb://127.0.0.1:27017/mytube", {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        });
    (7) 서버 파일에서 db파일 자체를 import한다
        import "./db";
    (8) shell에서 show dbs를 해주면, 아직 내가 연결한 db의 이름이 나오지 않는다
    (9) const db = mongoose.connection;
        db.on() 은 여러번 계속 밸생시킬 수 있다 (클릭과 같은 이벤트 처럼)
        db.once() 는 오로지 한번만 발생한다는 뜻이다
-----------------------------------------------------------------------------------
# 6.9 CRUD introduction
    (1) src폴더안에 models이란 폴더를 생성한다
        models 폴더안에 Video.js 파일을 만들어서 비디오 model을 만든다
    (2) model (파일과 모델명의 앞글자는 대문자로 작성한다)
        1. mongoose에게, 나의 어플리케이션의 데이터들이 어떻게 생겼는지 알려줘야한다
            ex) 비디오에 제목이 있고, 세부설명이 있고, 이들의 타입은 무엇인지 등등
        2. 이렇게 알려주면, mongoose는 데이터를 CRUD 할수있게 도와준다
-----------------------------------------------------------------------------------
# 6.10 Video +Model
    (1) mongoose를 import 해준다
    (2) model을 생성하기 전에, model의 형태를 정의해 줄 필요가 있다
        그 형태는 보통 schema라고 알려져 있다
            const videoSchema = new mongoose.Schema({}) 안에 데이터의 형태를 정의한다
    (3) model 을 만들어 준다
        const movieModel = mongoose.model("모델이름", SchemaName);
    (4) model 을 export 해준다
    (5) model 의 존재를 모두에게 알려준다
        서버 파일에서 import해준다
    Recap
        1. video의 형태(schema) 정의
        2. model 이름과 schema를 이용해서 model 생성
        3. model 을 default로 export 해준다
        4. server.js에 database를 import 해 연결시킨 후, 
            해당 연결이 성공적일 때, video를 import 해준다
            위 연결로 db는 video model을 인지한다
-----------------------------------------------------------------------------------
# 6.11 First Query
    (1) src 폴더에 init.js 파일을 생성한다
        이 파일에서는 모든걸 초기화시켜준다
            server.js는 express 된 것들, server의 configuration에 관련된 코드만 처리하기 위해
            나머지(database나 models 같은 것들의 import 등)는 init파일에서 관리해준다
                필요한 모든 것들을 import 시키는 역할
    (2) package.json 의 scripts수정
    (3) 이제 database 와 연결해야 하는데, mongoose documentation 참조
    (4) mongoose의 model 들은 CRUD operation을 돕는 많은 function 들을 제공한다
    (5) model.find() 의 결우 database가 종료되거나, 바쁘거나, 전송속도가 느리거나 등의 상황이 발생할 수 있다
        database는 javascript 밖에 존재하기 때문
        기다림이 필요할 때가 있다
    (6) 기다림에는 두가지를 활용할 수 있다
        1. callback function 을 활용
        2. promise 를 사용
    (7) callback 이란 무언가가 발생하고 난 다음 호출되는 function을 말한다
        configuration 과 호출할 function이 필요함 ex) app.listen(PORT, handleListening)
            Video.find({}, (error, documents) => {})
                중괄호는 search terms 를 나타내는데 비어있으면 모든 형식을 찾는다는 것을 뜻한다
                callback 은 error와 documents 라는 signature 를 가진다
-----------------------------------------------------------------------------------
# 6.12 First Query part Two
    (1) mongoose 는 Video.find({}, 를 database에서 불러온다
        database가 반응하면 mongoose는 (error, documents) => {}) 이 function을 실행한다
    (2) callback 을 사용하면 아무것도 return 되지 않아야 한다
        특정 코드를 마지막에 실행되게 한다
    (3) logger는 request가 완성되면(render되면) 출력이 되야한다
-----------------------------------------------------------------------------------
# 6.13 Async Await
    (1) promise 는 callback의 최신 버전이라 생각할 수 있다
    (2) error는 try catch 문으로 잡아낸다
    (3) async와 await의 최대 장점은 직관적이라는 것이다
    (4) await는 asynchronous인 function 안에서만 사용이 가능하다
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------