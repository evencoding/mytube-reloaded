#7 USER AUTHENTICATION
-----------------------------------------------------------------------------------
# 7.0 Create Account part One
    (1) 지난 Section에서 연습한 것들을 모두 사용하고, 여기에 인증(Authentication)을 추가한다
    (2) 유저 CRUD를 만든다
        Schema에 unique를 추가했음
-----------------------------------------------------------------------------------
# 7.1 Create Account part Two
    (1) DeprecationWarning은 만든지 오래된 기능을 쓰고 있으니까 업데이트 하라고 알려주는 것
    (2) post로 받아보면 db상에 password가 그대로 노츨된다
        보안 상 아주 좋지 못함
    (3) password를 봐도 무슨 말인지 모르게 만들어야 한다.
        password hashing
            원래 password를 알지 못해도 password가 일치하는지 안하는지 알 수 있다.
-----------------------------------------------------------------------------------
# 7.2 Create Account part Three
    (1) DB에 password를 저장하면 안된다.
    (2) 해싱은 일방향이라 되돌릴 수 있다
        입력 값으로 출력 앖을 알아내는데, 출력 값으로 입력 값을 알아낼 수 없다
        입력 값이 같다면, 출력 값은 항상 같다 (Deterministic function)결정적 함수
    (3) 전에 만든 유저를 지우고 다시 만드는데 이번엔 password를 해싱 해 준다
    (4) 해싱할 때 사용할건 bcrypt이다 (https://www.npmjs.com/package/bcrypt)
        npm i bcrypt 으로 설치
            해커가 rainbow table을 이용해서 해싱 된 비밀번호를 알아낼 수 있다
            bcrypt는 이 rainbow table 공격을 막아준다.
    (5) bcrypt.hash(myPlaintextPassword, saltRounds, function(err, hash) {
            // Store hash in your password DB.
        }); 를 사용
        await를 하는 것으로 callback을 하지 않는 방법도 있다. (saltRounds까지만 써주면 됨)
            saltRounds 는 해싱을 몇번 을 해줄 것인지를 말한다.
    (6) db에 저장하기전에 pre("save") middleware에서 password를 해싱한다
    (7) mongo에서 확인해보면 해싱된 password가 들어있는 것을 볼 수 있다
-----------------------------------------------------------------------------------
# 7.3 Form Validation
    (1) User를 새로 만들 때 이미 존재하는 데이터를 저장하면 에러가 발생한다
    (2) 에러를 체크해서 유저에게 알려줘야 한다
    (3) 컨트롤러에서 이미 db에 존재하는 유저네임,이메일인지를 확인하고, 존재한다면 에러 메세지를 보낸다.
    (4) 각각을 따로 체크해주는게 가장 좋은 방법일 순 있지만, 중복을 피하고 싶다면
        $or operator 라는걸 쓸 수 있다
            각 조건이 true일 때 실행되게 만들 수 있다
            안에 배열이 들어가고 그 중 어떤 조건이 하나라도 true이면 해당 데이터를 찾아온다
    (5) 패스워드를 확인할 수 있는 input을 하나 추가한다
-----------------------------------------------------------------------------------
# 7.4 Status Codes
    (1) 브라우저에서 로그인할 때 패스워드를 저장할거냐고 묻는다
    (2) 200 -> OK
        4xx -> client errors
            400 -> bad request
    (3) 브라우저에게 에러가 난거니까 저장할거냐고 묻지마~
        return res.status(400).render("join", {~~});
        status코드를 추가해 주면 된다
-----------------------------------------------------------------------------------
# 7.5 Login part One
    (1) 로그인 페이지 만들기
    (2) /login으로 post 요청을 받았을 때 어떻게 하면 될까?
        우선 입력한 username을 가진 User가 존재하는지 확인해야한다
        그리고 password를 확인해야한다
    (3) postLogin 컨트롤러를 만든다
        mongoose를 사용해서 username과 일치하는 User가 있는지 확인
        존재하지 않다면 error메세지와 함께 login페이지로 보내준다, 이 때 status코드는 400
-----------------------------------------------------------------------------------
# 7.6 Login part Two
    (1) DB에는 해싱된 패스워드가 있다.
    (2) 유저가 입력한 비밀번호를 해싱한 후에 DB의 데이터와 비교한다
    (3) bcrypt 안에 compare함수를 이용한다
        const ok = await bcrypt.compare(password, user.password)  (사용자가 입력 한 pw, 해싱 된 DB안의 pw) 결과는 boolean
    (4) 로그인이 됐다면 redirect로 /으로 보내준다
    (5) 로그인했다는 말은 접속한 유저가 누구인지 기억하고 있다는 뜻
    (6) 이걸 위해서는 쿠키와 세션에 대해 알아야한다.
-----------------------------------------------------------------------------------
# 7.7 Sessions and Cookies part One
    (1) 유저를 기억하게 만들기
    (2) 쿠키를 이해하기 위해서는 세션을 알아야한다.
        세션은 백엔드와 브라우저 간에 어떤 활동을 했는지 기억하는걸 말한다
            브라우저와 백엔드 사이의 memory, history와 같은 것
    (3) 이것이 적동하려면 백엔드와 브라우저가 서로에 대한 정보를 가지고 있어야 한다.
        로그인 페이지에서 HTTP 요청을 하면 요청이 처리되고 끝나게 되는데, 그 이후로는 백엔드가 아무 것도 할 수 없다.
    (4) 한 번 연결이 되었다가 끝난다. 이 둘 사이 연결에 state가 없다.
        이것을 stateless라고 한다
    (5) 따라서 유저한테 어떤 정보를 남겨줘야 한다.
        유저가 백엔드에 뭔가 요철 할 때마다 누가 요청하는지 알 수 있도록.
    (6) 유저가 로그인 할 때마다 조그마한 텍스트와 같은 것을 줄 것이다.
    (7) 포인트는 유저가 로그인 할 때마다 유저에게 그 유저라는 것을 알 수 있는 무언가를 준다는 것이다
    (8) 유저가 요청할 때마다 유저를 특정할 수 있는 텍스트를 같이 받는다

    (9) npm i express-session 으로 설치한다
    (10) 서버에서 세션을 import한다
    (11) 그 후 이 미들웨어를 router 앞에 초기화해주면 된다
        이제 이 미들웨어가 사이트로 들어오는 모두를 기억하게 된다
-----------------------------------------------------------------------------------
# 7.8 Sessions and Cookies part Two
    (1) DB와 연결하지 않았기 때문에 서버를 재시작하면 세션도 잃는다
    (2) 

    () 내가 브라우저에서 웹사이트를 방문할 때마다 세션 미들웨어가 있으면
        express가 알아서 그 브라우저를 위한 세견 id를 만들고, 브라우저한테 보내준다.
        그러면 브라우저가 쿠키에 그 세션 id를 저장하고, express에서도 그 세션을 세션 DB에 저장한다.
            세션 DB에 있는 id와 쿠키에 있는 id가 같도록
        그러면 브라우저한테 보내서 쿠키에 저장한 세션 id를 브라우저가 localhost:~~의 모든 url에 요철을 보낼 때마다
        세션 id를 요철과 함께 보낼것이다
        그러면 백엔드에서 어떤 유저가, 어떤 브라우저에서 요철을 보냈는지 알 수 있다
-----------------------------------------------------------------------------------
# 7.9 Logged in User
    (1) 누가 로그인 했는지 기억하도록 만든다
        기억한다기 보다는 1초마다 까먹는 사람한테 질문 받을 때 마다 정보가 담긴 카드를 건네는 것과 같다
    (2) user controller에서 유저가 로그인하면 그 유저에 대한 정보를 세션에 담는다.
        각 브라우저마다 서로 다른 세션을 가지고 있다
    (3) 세션 정보에 맞게 템플릿을 수정한다
    (4) 현재 req.session object에 정보를 저장하고 있다.
        유저가 로그인에 성공했는지 안했는지 상관없이.
        어떤 정보든지 추가할 있는데, 여기서는 loggedIn과 user를 추가했다
    (5) pug가 req.session이 뭔지 모르는기에 알려줘야 한다
-----------------------------------------------------------------------------------
# 7.10 Logged In User part Two
    (1) Response Object를 console.log 해보면 locals 이라는 것이 존재한다.
        현재는 비어있는 Object이다
        pug template에서 locals에 접근할 수 있다.(기본적으로 되는것) 
            local.~도 아니고 그냥 ~ 즉, 변수만으로 접근 가능
    (2) 이런 방식으로 템플릿과 소통한다 
        이는 글로벌 변수이기에 모든 템플릿에서 사용가능하다.
    (3) middlewares.js라는 파일을 생성해서 몇 개의 locals을 설정해준다
    (4) 이제 locals을 통해 누가 로그인했는지 공유한다
    (5) locals middleware가 session middleware보다 뒤에 오기 때문에 가능
        localsMiddleware가 session object에 접근 하기 위해
    (6) user정보도 session에 들어있기 때문에 locals에 넘겨줘서 템플릿과 공유
-----------------------------------------------------------------------------------
# 7.11 Recap
    (1) 
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------